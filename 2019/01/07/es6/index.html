<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>es6语法学习 | 前端笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="luhu,luhu's Blog">
  
  <meta name="description" content="箭头函数1 this箭头函数内的this值继承自外围作用域。运行时它会首先到它的父作用域找，如果父作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向。 2 箭头函数的特性箭头函数没有caller arguments: 箭头函数不仅没有this，常用的arguments也没有。如果你能获取到arguments，那它一定是来自父作用域的。箭头函数中不能使用 new箭头函数可以与变量解构结">
<meta name="keywords" content="es6 语法">
<meta property="og:type" content="article">
<meta property="og:title" content="es6语法学习">
<meta property="og:url" content="https://luhu9012.github.io/2019/01/07/es6/index.html">
<meta property="og:site_name" content="前端笔记">
<meta property="og:description" content="箭头函数1 this箭头函数内的this值继承自外围作用域。运行时它会首先到它的父作用域找，如果父作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向。 2 箭头函数的特性箭头函数没有caller arguments: 箭头函数不仅没有this，常用的arguments也没有。如果你能获取到arguments，那它一定是来自父作用域的。箭头函数中不能使用 new箭头函数可以与变量解构结">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-06-03T08:39:10.841Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="es6语法学习">
<meta name="twitter:description" content="箭头函数1 this箭头函数内的this值继承自外围作用域。运行时它会首先到它的父作用域找，如果父作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向。 2 箭头函数的特性箭头函数没有caller arguments: 箭头函数不仅没有this，常用的arguments也没有。如果你能获取到arguments，那它一定是来自父作用域的。箭头函数中不能使用 new箭头函数可以与变量解构结">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">luhu&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        luhu&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个专注 WEB 开发的技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Github" target="_blank" href="//luhu9012.github.io/">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-es6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      es6语法学习
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2019-01-07
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>1 this<br>箭头函数内的this值继承自外围作用域。运行时它会首先到它的父作用域找，如果父作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向。</p>
<p>2 箭头函数的特性<br>箭头函数没有caller arguments: 箭头函数不仅没有this，常用的arguments也没有。如果你能获取到arguments，那它一定是来自父作用域的。<br>箭头函数中不能使用 new<br>箭头函数可以与变量解构结合使用<br>箭头函数没有原型属性<br>箭头函数不能换行</p>
<p>3 箭头函数使用场景<br>替换es5的个that或者self变量方案<br>简化回调函数。<br>箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在map、reduce、filter的回调函数定义<br>空参箭头函数可以用于惰性求值：f = ()=&gt;表达式，使用f()求值</p>
<p>4 箭头函数优点<br>语法简洁</p>
<p>更直观的作用域和 this的绑定，它能让我们能很好的处理this的指向问题。箭头函数加上let关键字的使用，将会让我们javascript代码上一个层次。</p>
<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><blockquote>
<p>ES6 的类，完全可以看作构造函数的另一种写法<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Point()</span><br><span class="line"></span><br><span class="line">// 类的数据类型就是函数，类本身就指向构造函数。</span><br><span class="line">typeof Point // &quot;function&quot;</span><br><span class="line">Point === Point.prototype.constructor // true</span><br><span class="line"></span><br><span class="line">// p.constructor ===  Point.prototype.constructor // 实例的构造函数与es5表现一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 类的内部所有定义的方法，都是不可枚举的（non-enumerable），这一点与 ES5 的行为不一致。</span><br><span class="line">Object.keys(Point.prototype)</span><br><span class="line">// [] </span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)</span><br><span class="line">// [&quot;constructor&quot;,&quot;toString&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>类的所有方法都定义在类的prototype上的，在类的实例上面调用方法，其实就是调用原型上的方法；</p>
</blockquote>
<blockquote>
<p>类的内部所有定义的方法，都是不可枚举的（non-enumerable），这一点与 ES5 的行为不一致；</p>
</blockquote>
<blockquote>
<p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法,没有事默认添加空的constructor；</p>
</blockquote>
<blockquote>
<p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象；</p>
</blockquote>
<blockquote>
<p>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行；</p>
</blockquote>
<blockquote>
<p>实例的<strong>proto</strong>指向构造函数的prototype, 所以可以通过实例的<strong>proto</strong>属性为“类”添加方法。(必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。)</p>
</blockquote>
<blockquote>
<p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为;</p>
</blockquote>
<blockquote>
<p>类的属性名，可以采用表达式’<a href>methoname</a>{}’</p>
</blockquote>
<blockquote>
<p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式；</p>
</blockquote>
<blockquote>
<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
</blockquote>
<blockquote>
<p>ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性,name 属性总是返回紧跟在 class 关键字后面的类名；</p>
</blockquote>
<blockquote>
<p>类的static静态方法不会被实例继承，如果静态方法包含this关键字，这个this指的是类，而不是实例；父类的静态方法，可以被子类继承；</p>
</blockquote>
<blockquote>
<p>与函数一样，类也可以使用表达式的形式定义。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//例子1</span><br><span class="line">const MyClass = class Me &#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    return Me.name;// Me只能在内部可用，外部只能用MyClass的引用</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 如果类的内部没用到的话，可以省略Me</span><br><span class="line">const MyClass = class &#123; /* ... */ &#125;;</span><br><span class="line"></span><br><span class="line">// 可以写成立即执行类</span><br><span class="line">let person = new class &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(&apos;张三&apos;);</span><br><span class="line"></span><br><span class="line">person.sayName(); // &quot;张三&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>如果类的某个方法之前加上星号（*），就表示该方法是一个 Generator 函数：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  class Foo &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    this.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [Symbol.iterator]() &#123;</span><br><span class="line">    for (let arg of this.args) &#123;</span><br><span class="line">      yield arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// hello</span><br><span class="line">// world</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层</p>
</blockquote>
<blockquote>
<p>class的this指向：类的非静态方法中的this默认指向类的实例，但是如果将方法单独取出来用，则由于严格模式this将为undefined，这种情况下为了是this指向正确，可采取的三个方式：</p>
<ol>
<li>在构造函数中绑定this<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.printName = this.printName.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<ol start="2">
<li><p>在构造函数中使用箭头函数固定this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Obj &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.getThis = () =&gt; this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myObj = new Obj();</span><br><span class="line">myObj.getThis() === myObj // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>在获取方法的时候，使用proxy绑定this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function selfish (target) &#123;</span><br><span class="line">  const cache = new WeakMap();</span><br><span class="line">  const handler = &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      const value = Reflect.get(target, key);</span><br><span class="line">      if (typeof value !== &apos;function&apos;) &#123;</span><br><span class="line">        return value;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      return cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  const proxy = new Proxy(target, handler);</span><br><span class="line">  return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = selfish(new Logger());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="class-私有属性-私有方法设置"><a href="#class-私有属性-私有方法设置" class="headerlink" title="class 私有属性/私有方法设置"></a>class 私有属性/私有方法设置</h4><blockquote>
<p>一种做法是在命名上加以区别,比如下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法；</p>
</blockquote>
<blockquote>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(this, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(baz) &#123;</span><br><span class="line">  return this.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const bar = Symbol(&apos;bar&apos;);</span><br><span class="line">const snaf = Symbol(&apos;snaf&apos;);</span><br><span class="line"></span><br><span class="line">export default class myClass&#123;</span><br><span class="line"></span><br><span class="line">  // 公有方法</span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    this[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 私有方法</span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    return this[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  #count = 0;// 私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&apos;Getting the current value!&apos;);</span><br><span class="line">    return this.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承:"></a>Class的继承:</h4><p>  Class之间可以通过 extends 关键字实现继承;<br>  子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。</p>
<p>  es5 es6继承区别：</p>
<p>  ES5的继承，实质是先创造子类的实例对象 this ，然后再将父类的方法添加到 this 上面（ Parent.apply(this) ）。ES6的继承机制完全不同，实质是先创造父类的实例对象 this （所以必须先调用 super 方法），然后再用子类的构造函数修改 this 。</p>
<p>  在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例。</p>
<p>  es5 如果想继承原生构造函数（例如Array），因为原生构造函数的this无法绑定（Array.apply(this)无效），导致拿不到原生对象的内部属性。ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。因此extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数</p>
<blockquote>
<p>类的prototype属性和<strong>proto</strong>属性：</p>
</blockquote>
<p>Class作为构造函数的语法糖，即表示对象又标识构造函数，所以同时有prototype属性和 <strong>proto</strong> 属性，因此同时存在两条继承链</p>
<p>（1）子类的 <strong>proto</strong> 属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类 prototype 属性的 <strong>proto</strong> 属性，表示方法的继承，总是指向父类的 prototype 属性。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// class B extends A &#123;&#125; 与下边等价</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// B 的实例继承 A 的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line">// B 继承 A 的静态属性</span><br><span class="line">Object.setPrototypeOf(B, A);</span><br><span class="line"></span><br><span class="line">const a = new A()</span><br><span class="line"></span><br><span class="line">const b = new B();</span><br><span class="line"></span><br><span class="line">// 所以有这样的结果</span><br><span class="line">B.__proto__ = A</span><br><span class="line">B.prototype.__proto__ = A.prototype</span><br><span class="line"></span><br><span class="line">// 实例的__proto__</span><br><span class="line">b.__proto__.__proto__ = a.__proto__  // 子例的原型的原型是父例的原型</span><br><span class="line">b.__proto__ === B.prototype // 实例的__proto__指向其构造函数的prototype</span><br><span class="line"></span><br><span class="line">// A作为一个基类时：</span><br><span class="line">A.__proto__ === Function.prototype // true</span><br><span class="line">A.prototype.__proto__ === Object.prototype // true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// setPrototypeOf的实现</span><br><span class="line">Object.setPrototypeOf = function (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>extends 关键字后面可以跟多种类型的值：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 只要是一个有 prototype 属性的函数，就能被 B 继承。由于函数都有 prototype 属性（除了 Function.prototype 函数），因此 A 可以是任意函数。</span><br><span class="line"></span><br><span class="line">class C extends Object&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super(...arguments) // 无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var o = new C(&#123;attr: true&#125;);</span><br><span class="line">o.attr === true  // false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="new-target属性与-抽象类的实现"><a href="#new-target属性与-抽象类的实现" class="headerlink" title="new.target属性与 抽象类的实现"></a>new.target属性与 抽象类的实现</h4><p> ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<p> 注意的是，在函数外部使，用new.target会报错。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  if (new.target !== undefined) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error(&apos;必须使用 new 命令生成实例&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  if (new.target === Person) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error(&apos;必须使用 new 命令生成实例&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;张三&apos;); // 正确</span><br><span class="line">var notAPerson = Person.call(person, &apos;张三&apos;);  // 报错</span><br><span class="line"></span><br><span class="line">// class 内的new.target</span><br><span class="line">class Rectangle &#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    console.log(new.target === Rectangle);</span><br><span class="line">    this.length = length;</span><br><span class="line">    this.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = new Rectangle(3, 4); // 输出 true</span><br><span class="line"></span><br><span class="line">// 子类继承父类时，new.target会返回子类</span><br><span class="line">// 借此实现抽象类：不能被实例化，只能被继承</span><br><span class="line">class Shape &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    if (new.target === Shape) &#123;</span><br><span class="line">      throw new Error(&apos;本类不能实例化&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle extends Shape &#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    super();</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = new Shape();  // 报错</span><br><span class="line">var y = new Rectangle(3, 4);  // 正确</span><br></pre></td></tr></table></figure></p>
<h4 id="MIXIN-组合模式"><a href="#MIXIN-组合模式" class="headerlink" title="MIXIN 组合模式"></a>MIXIN 组合模式</h4><p> Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> // 最简单实现</span><br><span class="line"> const a = &#123;</span><br><span class="line">  a: &apos;a&apos;</span><br><span class="line">&#125;;</span><br><span class="line">const b = &#123;</span><br><span class="line">  b: &apos;b&apos;</span><br><span class="line">&#125;;</span><br><span class="line">const c = &#123;...a, ...b&#125;; // &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125;</span><br><span class="line"></span><br><span class="line">// 更完备的实现，将多个类的接口“混入”（mix in）另一个类,将多个对象合成为一个类,使用的时候，只要继承这个类即可</span><br><span class="line"></span><br><span class="line">function mix(...mixins)&#123;</span><br><span class="line">  class Mix&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">      for(let mixin of mixins)&#123;</span><br><span class="line">        copyPropety(this,new mixins()) // 复制mixin实例上的属性到目标实例（this）上</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(let mixin of mixins)&#123;</span><br><span class="line">    copyPropety(Mix,mixin) // 复制静态属性</span><br><span class="line">    copyPropety(Mix.prototype,mixin.prototype) // 复制原型上的属性</span><br><span class="line">  &#125;</span><br><span class="line">  return Mix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copyPropety(target,source)&#123;</span><br><span class="line">  for(let key of Reflect.ownKeys(source))&#123;</span><br><span class="line">    if(key!==&apos;name&apos; &amp;&amp; key!==&apos;constructor&apos; &amp;&amp; key!==&apos;prototype&apos;)&#123;</span><br><span class="line">      let desc = Object.getOwnPropertyDescriptor(source, key);</span><br><span class="line">      Reflect.defineProperty(target,key,desc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用 </span><br><span class="line">class DistributedEdit extends mix(Loggable, Serializable) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h4 id="thunk函数"><a href="#thunk函数" class="headerlink" title="thunk函数"></a>thunk函数</h4><p>  编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。<br> 在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p>
<h3 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h3><p> <a href="https://www.jianshu.com/p/43de678e918a" target="_blank" rel="noopener">https://www.jianshu.com/p/43de678e918a</a><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/ 定义Promise的三种状态常量</span><br><span class="line">const PENDING = &apos;PENDING&apos;</span><br><span class="line">const FULFILLED = &apos;FULFILLED&apos;</span><br><span class="line">const REJECTED = &apos;REJECTED&apos;</span><br><span class="line"></span><br><span class="line">class Promise&#123;</span><br><span class="line">  constructor(handel)&#123;</span><br><span class="line">    if(typeof handle !== &apos;function&apos;)&#123;</span><br><span class="line">      throw new Error(&apos;只接受函数参数&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加状态</span><br><span class="line">    this._status = PENDING</span><br><span class="line">    // 添加值</span><br><span class="line">    this._value = undefined</span><br><span class="line">    //执行handle</span><br><span class="line">    try&#123;</span><br><span class="line">      handle(this._resolve.bind(this),this._reject.bind(this))</span><br><span class="line"></span><br><span class="line">    &#125;catch(err)&#123;</span><br><span class="line">      this._reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加reject时执行的函数</span><br><span class="line">  _reject(err)&#123;</span><br><span class="line">     if(this._status !== PENDING) return</span><br><span class="line">     this._status = REJECTED</span><br><span class="line">     this._value = err</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加resolve时执行的函数</span><br><span class="line">  _resolve(val)&#123;</span><br><span class="line">    if(this._status !== PENDING) return</span><br><span class="line">    this._status = FULFILLED</span><br><span class="line">    this._value = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">  // 判断变量否为function</span><br><span class="line">const isFunction = variable =&gt; typeof variable === &apos;function&apos;</span><br><span class="line">// 定义Promise的三种状态常量</span><br><span class="line">const PENDING = &apos;PENDING&apos;</span><br><span class="line">const FULFILLED = &apos;FULFILLED&apos;</span><br><span class="line">const REJECTED = &apos;REJECTED&apos;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  constructor (handle) &#123;</span><br><span class="line">    if (!isFunction(handle)) &#123;</span><br><span class="line">      throw new Error(&apos;MyPromise must accept a function as a parameter&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加状态</span><br><span class="line">    this._status = PENDING</span><br><span class="line">    // 添加状态</span><br><span class="line">    this._value = undefined</span><br><span class="line">    // 添加成功回调函数队列</span><br><span class="line">    this._fulfilledQueues = []</span><br><span class="line">    // 添加失败回调函数队列</span><br><span class="line">    this._rejectedQueues = []</span><br><span class="line">    // 执行handle</span><br><span class="line">    try &#123;</span><br><span class="line">      handle(this._resolve.bind(this), this._reject.bind(this)) </span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      this._reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加resovle时执行的函数</span><br><span class="line">  _resolve (val) &#123;</span><br><span class="line">    const run = () =&gt; &#123;</span><br><span class="line">      if (this._status !== PENDING) return</span><br><span class="line">      this._status = FULFILLED</span><br><span class="line">      // 依次执行成功队列中的函数，并清空队列</span><br><span class="line">      const runFulfilled = (value) =&gt; &#123;</span><br><span class="line">        let cb;</span><br><span class="line">        while (cb = this._fulfilledQueues.shift()) &#123;</span><br><span class="line">          cb(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 依次执行失败队列中的函数，并清空队列</span><br><span class="line">      const runRejected = (error) =&gt; &#123;</span><br><span class="line">        let cb;</span><br><span class="line">        while (cb = this._rejectedQueues.shift()) &#123;</span><br><span class="line">          cb(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,</span><br><span class="line">        当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态</span><br><span class="line">      */</span><br><span class="line">      if (val instanceof MyPromise) &#123;</span><br><span class="line">        val.then(value =&gt; &#123;</span><br><span class="line">          this._value = value</span><br><span class="line">          runFulfilled(value)</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">          this._value = err</span><br><span class="line">          runRejected(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this._value = val</span><br><span class="line">        runFulfilled(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 为了支持同步的Promise，这里采用异步调用</span><br><span class="line">    setTimeout(run, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加reject时执行的函数</span><br><span class="line">  _reject (err) &#123; </span><br><span class="line">    if (this._status !== PENDING) return</span><br><span class="line">    // 依次执行失败队列中的函数，并清空队列</span><br><span class="line">    const run = () =&gt; &#123;</span><br><span class="line">      this._status = REJECTED</span><br><span class="line">      this._value = err</span><br><span class="line">      let cb;</span><br><span class="line">      while (cb = this._rejectedQueues.shift()) &#123;</span><br><span class="line">        cb(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 为了支持同步的Promise，这里采用异步调用</span><br><span class="line">    setTimeout(run, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加then方法</span><br><span class="line">  then (onFulfilled, onRejected) &#123;</span><br><span class="line">    const &#123; _value, _status &#125; = this</span><br><span class="line">    // 返回一个新的Promise对象</span><br><span class="line">    return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123;</span><br><span class="line">      // 封装一个成功时执行的函数</span><br><span class="line">      let fulfilled = value =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          if (!isFunction(onFulfilled)) &#123;</span><br><span class="line">            onFulfilledNext(value)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            let res =  onFulfilled(value);</span><br><span class="line">            if (res instanceof MyPromise) &#123;</span><br><span class="line">              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span><br><span class="line">              onFulfilledNext(res)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          // 如果函数执行出错，新的Promise对象的状态为失败</span><br><span class="line">          onRejectedNext(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 封装一个失败时执行的函数</span><br><span class="line">      let rejected = error =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          if (!isFunction(onRejected)) &#123;</span><br><span class="line">            onRejectedNext(error)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              let res = onRejected(error);</span><br><span class="line">              if (res instanceof MyPromise) &#123;</span><br><span class="line">                // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span><br><span class="line">                res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span><br><span class="line">                onFulfilledNext(res)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          // 如果函数执行出错，新的Promise对象的状态为失败</span><br><span class="line">          onRejectedNext(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      switch (_status) &#123;</span><br><span class="line">        // 当状态为pending时，将then方法回调函数加入执行队列等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._fulfilledQueues.push(fulfilled)</span><br><span class="line">          this._rejectedQueues.push(rejected)</span><br><span class="line">          break</span><br><span class="line">        // 当状态已经改变时，立即执行对应的回调函数</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilled(_value)</span><br><span class="line">          break</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejected(_value)</span><br><span class="line">          break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加catch方法</span><br><span class="line">  catch (onRejected) &#123;</span><br><span class="line">    return this.then(undefined, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加静态resolve方法</span><br><span class="line">  static resolve (value) &#123;</span><br><span class="line">    // 如果参数是MyPromise实例，直接返回这个实例</span><br><span class="line">    if (value instanceof MyPromise) return value</span><br><span class="line">    return new MyPromise(resolve =&gt; resolve(value))</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加静态reject方法</span><br><span class="line">  static reject (value) &#123;</span><br><span class="line">    return new MyPromise((resolve ,reject) =&gt; reject(value))</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加静态all方法</span><br><span class="line">  static all (list) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      /**</span><br><span class="line">       * 返回值的集合</span><br><span class="line">       */</span><br><span class="line">      let values = []</span><br><span class="line">      let count = 0</span><br><span class="line">      for (let [i, p] of list.entries()) &#123;</span><br><span class="line">        // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span><br><span class="line">        this.resolve(p).then(res =&gt; &#123;</span><br><span class="line">          values[i] = res</span><br><span class="line">          count++</span><br><span class="line">          // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span><br><span class="line">          if (count === list.length) resolve(values)</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">          // 有一个被rejected时返回的MyPromise状态就变成rejected</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加静态race方法</span><br><span class="line">  static race (list) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      for (let p of list) &#123;</span><br><span class="line">        // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span><br><span class="line">        this.resolve(p).then(res =&gt; &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  finally (cb) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">      value  =&gt; MyPromise.resolve(cb()).then(() =&gt; value),</span><br><span class="line">      reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>  解决属性重名的问题</p>
<blockquote>
<p>Symbol(xx)返回的第一无二的值,参数相同也是不相等的，Symbol(xx).description读取xx<br>Symbol 值不能与其他类型的值进行运算，会报错，但是可以显示转化为字符串String(sym)、sym.toString()<br>typeof Symblo === ‘symbol<br>Symbol 值作为对象属性名时，不能用点运算符，只能用中括号运算符<br>Symbol 作为属性名不会被for in/for of/Object.keys/Object.getOwnPropertyNames/JSON.stringify 遍历或返回，可以通过Object.getOwnPropertySymbols、Reflect.ownKeys方法获取<br>Symbol.for在全局注册并可重复使用，Symbol.keyFor返回已注册的Symbol类型值得key<br>使用Symbol属性名可以方便的构建单例模式</p>
</blockquote>
<h4 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h4><blockquote>
<p>Symbol.hasInstance instanceof运算符调用该属性对应方法<br>Symbol.isConcatSpreadable  concat方法调用时，该属性名对应的布尔值决定对象是否可被展开<br>Symbol.species 实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例<br>Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。<br>Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。<br>Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。<br>Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。<br>Symbol.iterator属性，指向该对象的默认遍历器方法<br>Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。<br>ymbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串<br>Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</p>
</blockquote>
<h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><blockquote>
<p>解决目标：</p>
<ol>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上;</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false;</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为;</li>
</ol>
</blockquote>
<blockquote>
<p>Reflect一共13个静态方法：</p>
<ol>
<li>Reflect.get(target, name, receiver) 查找并返回target对象的name属性，如果没有该属性，则返回undefined。如果name属性部署了读取函数（getter），则读取函数的this绑定receiver</li>
<li>Reflect.set(target, name, value, receiver)  设置target对象的name属性等于value；如果name属性设置了赋值函数，则赋值函数的this绑定receiver；<br>注意，如果 Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截</li>
<li>Reflect.deleteProperty(obj, name)  基本等同于Object.defineProperty</li>
<li>Reflect.has(obj, name)  对应name in obj里面的in运算符；如果Reflect.has()方法的第一个参数不是对象，会报错；</li>
<li>Reflect.deleteProperty(obj, name) 等同于delete obj[name]，用于删除对象的属性</li>
<li>Reflect.construct(target, args)  等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法</li>
<li>Reflect.getPrototypeOf(obj) 用于读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)，区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。</li>
<li>Reflect.setPrototypeOf(obj, newProto)</li>
<li>Reflect.apply(func, thisArg, args)</li>
<li>Reflect.getOwnPropertyDescriptor(target, propertyKey)</li>
<li>Reflect.isExtensible (target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.ownKeys (target)  Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。</li>
</ol>
</blockquote>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><blockquote>
<p>this问题<br>    在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br>    有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。解决办法是：将this绑定原始对象<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  const target = new Date(&apos;2015-01-01&apos;);</span><br><span class="line">const handler = &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    if (prop === &apos;getDate&apos;) &#123;</span><br><span class="line">      return target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate() // 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>#### Object.assign
&gt; 第一个参数是null或者undefined会报错，第二参数是null或者undefined不会报错，会忽略
&gt; 第二参数如果不是对象：是字符串的话会以数组形式拷贝如目标对象，其他类型如数字或者布尔值都忽略
&gt; 只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）
&gt; Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用
&gt; 一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。
&gt; Object.assign可以用来处理数组，但是会把数组视为对象
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign([1, 2, 3], [4, 5])</span><br><span class="line">// [4, 5, 3]</span><br></pre></td></tr></table></figure>

  &gt; Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制</code></pre>
            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年06月03日 16:39</p>
        <p>原始链接： <a class="post-url" href="/2019/01/07/es6/" title="es6语法学习">https://luhu9012.github.io/2019/01/07/es6/</a></p>
        <footer>
            <a href="https://luhu9012.github.io">
                <img src="/images/logo.png" alt="luhu9012">
                luhu9012
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://luhu9012.github.io/2019/01/07/es6/&title=《es6语法学习》 — 前端笔记&pic=https://luhu9012.github.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://luhu9012.github.io/2019/01/07/es6/&title=《es6语法学习》 — 前端笔记&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://luhu9012.github.io/2019/01/07/es6/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6语法学习》 — 前端笔记&url=https://luhu9012.github.io/2019/01/07/es6/&via=https://luhu9012.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://luhu9012.github.io/2019/01/07/es6/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://luhu9012.github.io/2019/01/07/es6/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/es6语法/" class="color2">es6 语法</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#箭头函数"><span class="post-toc-text">箭头函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#class"><span class="post-toc-text">class</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#class-私有属性-私有方法设置"><span class="post-toc-text">class 私有属性/私有方法设置</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Class的继承"><span class="post-toc-text">Class的继承:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#new-target属性与-抽象类的实现"><span class="post-toc-text">new.target属性与 抽象类的实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MIXIN-组合模式"><span class="post-toc-text">MIXIN 组合模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#thunk函数"><span class="post-toc-text">thunk函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Promise-实现"><span class="post-toc-text">Promise 实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Symbol"><span class="post-toc-text">Symbol</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内置的Symbol值"><span class="post-toc-text">内置的Symbol值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Reflect"><span class="post-toc-text">Reflect</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Promise"><span class="post-toc-text">Promise</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2019/02/04/bom/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          BOM 浏览器对象模型
        
      </span>
    </a>
  
  
    <a href="/2018/08/14/designpatterns/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">设计模式</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 luhu9012<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://luhu9012.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/bom/">bom</a><a class="category-link" href="/categories/css/">css</a><a class="category-link" href="/categories/js实践/">js实践</a><a class="category-link" href="/categories/js异步编程/">js异步编程</a><a class="category-link" href="/categories/动画/">动画</a><a class="category-link" href="/categories/框架/">框架</a><a class="category-link" href="/categories/设计模式/">设计模式</a><a class="category-link" href="/categories/项目/">项目</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/async-异步/" style="font-size: 10px;">async 异步</a> <a href="/tags/bfc/" style="font-size: 10px;">bfc</a> <a href="/tags/css-概念/" style="font-size: 10px;">css 概念</a> <a href="/tags/css动画-js动画/" style="font-size: 10px;">css动画 js动画</a> <a href="/tags/es6-语法/" style="font-size: 10px;">es6 语法</a> <a href="/tags/javaSciript/" style="font-size: 20px;">javaSciript</a> <a href="/tags/js-函数/" style="font-size: 10px;">js 函数</a> <a href="/tags/js-机制/" style="font-size: 10px;">js 机制</a> <a href="/tags/js基础-js运行机制/" style="font-size: 10px;">js基础 js运行机制</a> <a href="/tags/oop/" style="font-size: 10px;">oop</a> <a href="/tags/vue-js/" style="font-size: 10px;">vue.js</a> <a href="/tags/垂直居中/" style="font-size: 10px;">垂直居中</a> <a href="/tags/奇技淫巧/" style="font-size: 10px;">奇技淫巧</a> <a href="/tags/性能/" style="font-size: 16.67px;">性能</a> <a href="/tags/文件上传/" style="font-size: 13.33px;">文件上传</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/浏览器-V8/" style="font-size: 10px;">浏览器  V8</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/项目/" style="font-size: 13.33px;">项目</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/async-异步/" style="font-size: 10px;">async 异步</a> <a href="/tags/bfc/" style="font-size: 10px;">bfc</a> <a href="/tags/css-概念/" style="font-size: 10px;">css 概念</a> <a href="/tags/css动画-js动画/" style="font-size: 10px;">css动画 js动画</a> <a href="/tags/es6-语法/" style="font-size: 10px;">es6 语法</a> <a href="/tags/javaSciript/" style="font-size: 20px;">javaSciript</a> <a href="/tags/js-函数/" style="font-size: 10px;">js 函数</a> <a href="/tags/js-机制/" style="font-size: 10px;">js 机制</a> <a href="/tags/js基础-js运行机制/" style="font-size: 10px;">js基础 js运行机制</a> <a href="/tags/oop/" style="font-size: 10px;">oop</a> <a href="/tags/vue-js/" style="font-size: 10px;">vue.js</a> <a href="/tags/垂直居中/" style="font-size: 10px;">垂直居中</a> <a href="/tags/奇技淫巧/" style="font-size: 10px;">奇技淫巧</a> <a href="/tags/性能/" style="font-size: 16.67px;">性能</a> <a href="/tags/文件上传/" style="font-size: 13.33px;">文件上传</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/浏览器-V8/" style="font-size: 10px;">浏览器  V8</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/项目/" style="font-size: 13.33px;">项目</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>