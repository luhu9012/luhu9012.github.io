<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>数据结构与算法 | 前端笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="luhu,luhu's Blog">
  
  <meta name="description" content="8种常用数据结构数组、栈、队列、链表、散列表、树、图、堆 数组 的检索时间复杂度为O(1),插入与删除的复杂度为O(n),js中的数组几乎万能的，用来实现栈，队列等。数组在v8中的存储与扩容可以看这篇笔记  链表 单链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849">
<meta name="keywords" content="树">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="https://luhu9012.github.io/2019/08/04/algorithms/index.html">
<meta property="og:site_name" content="前端笔记">
<meta property="og:description" content="8种常用数据结构数组、栈、队列、链表、散列表、树、图、堆 数组 的检索时间复杂度为O(1),插入与删除的复杂度为O(n),js中的数组几乎万能的，用来实现栈，队列等。数组在v8中的存储与扩容可以看这篇笔记  链表 单链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://luhu9012.github.io/2019/08/04/imgs/danlianbiao.png">
<meta property="og:image" content="https://luhu9012.github.io/2019/08/04/imgs/shuanglianbiao.png">
<meta property="og:image" content="https://luhu9012.github.io/2019/08/04/imgs/xunhuandan.png">
<meta property="og:updated_time" content="2020-06-17T10:28:03.514Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与算法">
<meta name="twitter:description" content="8种常用数据结构数组、栈、队列、链表、散列表、树、图、堆 数组 的检索时间复杂度为O(1),插入与删除的复杂度为O(n),js中的数组几乎万能的，用来实现栈，队列等。数组在v8中的存储与扩容可以看这篇笔记  链表 单链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849">
<meta name="twitter:image" content="https://luhu9012.github.io/2019/08/04/imgs/danlianbiao.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">luhu&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        luhu&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个专注 WEB 开发的技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Github" target="_blank" href="//luhu9012.github.io/">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-algorithms" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      数据结构与算法
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2019-08-04
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h4 id="8种常用数据结构"><a href="#8种常用数据结构" class="headerlink" title="8种常用数据结构"></a>8种常用数据结构</h4><p>数组、栈、队列、链表、散列表、树、图、堆</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ol>
<li>的检索时间复杂度为O(1),插入与删除的复杂度为O(n),js中的数组几乎万能的，用来实现栈，队列等。数组在v8中的存储与扩容可以看<a href="./v8.md">这篇笔记</a></li>
</ol>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><ol>
<li><p>单链表<br><img src="../imgs/danlianbiao.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">function List()&#123;</span><br><span class="line">  // 节点</span><br><span class="line">  let Node = function(element)&#123;</span><br><span class="line">    this.element = element</span><br><span class="line">    this.next = null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 初始头节点</span><br><span class="line">  let head = null</span><br><span class="line"></span><br><span class="line">  // 链表长度</span><br><span class="line">  let length = 0</span><br><span class="line"></span><br><span class="line">   // 操作</span><br><span class="line"> this.getList = function() &#123;return head&#125;</span><br><span class="line"> // 查找节点是否存在</span><br><span class="line"> this.search = function(list, element) &#123;</span><br><span class="line">   let p = head</span><br><span class="line">   if(!p) return falst;</span><br><span class="line">   while(p)&#123;</span><br><span class="line">     if(p === element) return true</span><br><span class="line">     p = p.next</span><br><span class="line">   &#125;</span><br><span class="line">   return false</span><br><span class="line"> &#125;</span><br><span class="line"> // 追加节点</span><br><span class="line"> this.append = function(element) &#123;</span><br><span class="line">    let node = new Node(element),</span><br><span class="line">       p = head</span><br><span class="line">   if (!head)&#123;</span><br><span class="line">     head = node</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     while (p.next) &#123;</span><br><span class="line">       p = p.next</span><br><span class="line">     &#125;</span><br><span class="line">     p.next = node</span><br><span class="line">   &#125;</span><br><span class="line">   length += 1</span><br><span class="line"> &#125;</span><br><span class="line"> // 插入 position 的后继节点</span><br><span class="line"> this.insert = function(position, element) &#123;</span><br><span class="line">   if(position&gt;=0 &amp;&amp; position&lt; length+1)&#123;</span><br><span class="line">     let node = Node(element)</span><br><span class="line">     let pre = head,rear = head,index = 0</span><br><span class="line">     if(positon===0)&#123;</span><br><span class="line">       node.next = head</span><br><span class="line">       head = node</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       while(index&lt;position)&#123;</span><br><span class="line">         index++</span><br><span class="line">         pre = rear</span><br><span class="line">         rear = rear.next</span><br><span class="line">       &#125;</span><br><span class="line">       pre.next = node</span><br><span class="line">       node.next = rear</span><br><span class="line">       length++</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> 删除</span><br><span class="line"> this.remove = function(element)&#123;</span><br><span class="line">   let pre ,rear,current = head</span><br><span class="line">   while(current &amp;&amp; current!==element)&#123;</span><br><span class="line">     pre = current</span><br><span class="line">     current = current.next</span><br><span class="line">   &#125;</span><br><span class="line">   if(!current) return false</span><br><span class="line">   rear = current.next</span><br><span class="line">   pre.next = rear</span><br><span class="line">   current = null</span><br><span class="line">   length--</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> this.isEmpty = function()&#123;</span><br><span class="line">   return length === 0</span><br><span class="line"> &#125;</span><br><span class="line"> this.size = function()&#123;</span><br><span class="line">   return length</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>双链表<br><img src="../imgs/shuanglianbiao.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">function DoublyLinkedList()&#123;</span><br><span class="line">  // 节点</span><br><span class="line">  let Node = function(element)&#123;</span><br><span class="line">    this.element = element</span><br><span class="line">    this.next = null</span><br><span class="line">    this.pre = null</span><br><span class="line">  &#125;</span><br><span class="line">  // 头结点</span><br><span class="line">  let head = null</span><br><span class="line">  // 尾结点</span><br><span class="line">  let tail = null</span><br><span class="line">  // 链表长度</span><br><span class="line">  let length = 0</span><br><span class="line"></span><br><span class="line">  // 操作</span><br><span class="line">  this.search = function(element) &#123;</span><br><span class="line">    if(!head)</span><br><span class="line">  &#125;</span><br><span class="line">  this.insert = function(position, element) &#123;</span><br><span class="line">    if(position&gt;=0 &amp;&amp; positon&lt;=length)&#123;</span><br><span class="line">      let node = Node(element)</span><br><span class="line">      if(positon === 0)&#123;</span><br><span class="line">        if(!head)&#123;</span><br><span class="line">          head = node</span><br><span class="line">          tail = node</span><br><span class="line">          return true</span><br><span class="line">        &#125;</span><br><span class="line">         node.next = head</span><br><span class="line">         head.pre = node</span><br><span class="line">         head = node</span><br><span class="line">      &#125;else if(position===length)&#123;</span><br><span class="line">        tail.next = node</span><br><span class="line">        node.pre = tail</span><br><span class="line">        tail = node</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        let current= head,pre,rear,index = 0</span><br><span class="line">        while(index&lt;positon)&#123;</span><br><span class="line">          current = current.next</span><br><span class="line">          index++</span><br><span class="line">        &#125;</span><br><span class="line">        rear = current.next</span><br><span class="line">        current.next = node</span><br><span class="line">        node.pre = current</span><br><span class="line">        node.next = rear</span><br><span class="line">        rear.pre = node</span><br><span class="line">       </span><br><span class="line">      &#125;</span><br><span class="line">      length++</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.removeAt = function(position)&#123;</span><br><span class="line">    if(position&gt;=0 &amp;&amp; positon&lt;=length)&#123;</span><br><span class="line">      let returnNode</span><br><span class="line">      if(position === 0)&#123;</span><br><span class="line">        if(!head) return null</span><br><span class="line">        let next = head.next</span><br><span class="line">        next.pre = null</span><br><span class="line">        returnNode = head.element</span><br><span class="line">        head = next</span><br><span class="line">      &#125;else if(positon === length)&#123;</span><br><span class="line">        if(!tail) retrun false</span><br><span class="line">        let last = tail.pre</span><br><span class="line">        last.next = null</span><br><span class="line">        returnNode = tail.element</span><br><span class="line">        tail = last</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        let index = 0,current = head</span><br><span class="line">        while(index &lt; position)&#123;</span><br><span class="line">          current = current.next</span><br><span class="line">          index++</span><br><span class="line">        &#125;</span><br><span class="line">        let pre = current.pre</span><br><span class="line">        let rear = current.next</span><br><span class="line">        pre.next = rear</span><br><span class="line">        rear.pre = pre</span><br><span class="line">        returnNode = current.element</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      length--</span><br><span class="line">      return returnNode</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.isEmpty = function()&#123; return length === 0 &#125; </span><br><span class="line">  this.size = function()&#123; return length &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>循环单链表 循环双链表</li>
</ol>
<p>循环单链表是一种特殊的单链表，它和单链表的唯一区别是：单链表的尾节点指向的是 NULL，而循环单链表的尾节点指向的是头节点，这就形成了一个首尾相连的环：<br><img src="../imgs/xunhuandan.png" alt></p>
<p>循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针,或者 index++ &lt; length</p>
<p>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时可对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。</p>
</li>
</ol>
</li>
</ol>
<pre><code>由循环单链表的定义不难推出循环双链表，不同的是在循环双链表中，头结点的prior 指针还要指向表尾结点</code></pre><h4 id="常用的算法分类"><a href="#常用的算法分类" class="headerlink" title="常用的算法分类"></a>常用的算法分类</h4><p>检索、插入、删除、更新、排序</p>
<h4 id="复杂度分析：时间复杂度-、-空间复杂度"><a href="#复杂度分析：时间复杂度-、-空间复杂度" class="headerlink" title="复杂度分析：时间复杂度 、 空间复杂度"></a>复杂度分析：时间复杂度 、 空间复杂度</h4><p>从 CPU 的角度看，每段代码不过是读写数据或操作数据，尽管每次操作 CPU 执行的个数、执行的时间都不同，但我们粗咯把每次执行的时间都一致，称为 unit_time 。</p>
<p>时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。</p>
<p>当 n 无限大时，时间复杂度 T(n) 受 n 的最高数量级影响最大，与f(n) 中的常量、低阶、系数关系就不那么大了。所以我们分析代码的时间复杂度时，仅仅关注代码执行次数最多的那段就可以了。</p>
<p>常见的时间复杂度</p>
<blockquote>
<p>常量阶： O(1)：当算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</p>
</blockquote>
<blockquote>
<p>对数阶：O(logn): <figure class="highlight plain"><figcaption><span>i</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 线性阶：O(n): 比如一个循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 线性对数阶：O(nlogn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 平方阶、立方阶、….、k次方阶：O(n2)、O(n3)、…、O(nk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 指数阶：O(2k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 阶乘阶：O(n!)</span><br><span class="line"></span><br><span class="line">空间复杂度表示算法的存储空间与数据规模之间的增长关系</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 将扁平数组转化为树</span><br><span class="line"></span><br><span class="line">实现了用O(n)级算法将 一个扁平的数组即一维数组代表的菜单结构转换成一个多层级的菜单结构。</span><br><span class="line"></span><br><span class="line">一位数组中每一个元素必须要包含以下属性：</span><br><span class="line">1.拥有一个唯一的id</span><br><span class="line">2.拥有一个parent_id, 这个id指向它父级的id</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>var menu_list = [{<br>      id: ‘1’,<br>      menu_name: ‘设置’,<br>      menu_url: ‘setting’,<br>      parent_id: 0<br>    }, {<br>      id: ‘1-1’,<br>      menu_name: ‘权限设置’,<br>      menu_url: ‘setting.permission’,<br>      parent_id: ‘1’<br>    }, {<br>      id: ‘1-1-1’,<br>      menu_name: ‘用户管理列表’,<br>      menu_url: ‘setting.permission.user_list’,<br>      parent_id: ‘1-1’<br>    }, {<br>      id: ‘1-1-2’,<br>      menu_name: ‘用户管理新增’,<br>      menu_url: ‘setting.permission.user_add’,<br>      parent_id: ‘1-1’<br>    }, {<br>      id: ‘1-1-3’,<br>      menu_name: ‘角色管理列表’,<br>      menu_url: ‘setting.permission.role_list’,<br>      parent_id: ‘1-1’<br>    }, {<br>      id: ‘1-2’,<br>      menu_name: ‘菜单设置’,<br>      menu_url: ‘setting.menu’,<br>      parent_id: ‘1’<br>    }, {<br>      id: ‘1-2-1’,<br>      menu_name: ‘菜单列表’,<br>      menu_url: ‘setting.menu.menu_list’,<br>      parent_id: ‘1-2’<br>    }, {<br>      id: ‘1-2-2’,<br>      menu_name: ‘菜单添加’,<br>      menu_url: ‘setting.menu.menu_add’,<br>      parent_id: ‘1-2’<br>    }, {<br>      id: ‘2’,<br>      menu_name: ‘订单’,<br>      menu_url: ‘order’,<br>      parent_id: 0<br>    }, {<br>      id: ‘2-1’,<br>      menu_name: ‘报单审核’,<br>      menu_url: ‘order.orderreview’,<br>      parent_id: ‘2’<br>    }, {<br>      id: ‘2-2’,<br>      menu_name: ‘退款管理’,<br>      menu_url: ‘order.refundmanagement’,<br>      parent_id: ‘2’<br>    }<br>]</p>
<p>function buildTree(list){<br>    let temp = {};<br>    let tree = {};<br>    list.forEach(it=&gt;{<br>        temp[it.id]= it;<br>    })<br>    for(let i in temp ){<br>        let pa = temp[i].parent_id;// 判断父对象是否存在<br>        if(pa){<br>            if(!tem[pa].child){<br>                tem[pa].child = {};<br>            }<br>            temp[pa].child[tem[i].id] = temp[i];</p>
<pre><code>    }else{
        tree[i] = temp[i];// 父对象不存在时直接挂到根部
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 二叉树中和为某一值的路径  回溯法</span><br><span class="line"></span><br><span class="line">输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</span><br><span class="line"></span><br><span class="line">思路</span><br><span class="line"></span><br><span class="line">套用回溯算法的思路</span><br><span class="line"></span><br><span class="line">设定一个结果数组result来存储所有符合条件的路径</span><br><span class="line"></span><br><span class="line">设定一个栈stack来存储当前路径中的节点</span><br><span class="line"></span><br><span class="line">设定一个和sum来标识当前路径之和</span><br><span class="line"></span><br><span class="line">•从根结点开始深度优先遍历，没经过一个节点，将节点入栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">•到达叶子节点，且当前路径之和等于给定目标值，则找到一个可行的解决方案，将其加入结果数组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">•遍历到二叉树的某个节点时有2个可能的选项，选择前往左子树或右子树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">•若存在左子树，继续向左子树递归</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">•若存在右子树，继续向右子树递归</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">•若上述条件均不满足，或已经遍历过，将当前节点出栈，向上回溯</span><br></pre></td></tr></table></figure>

<p>function  findPath(root,expectNum){<br>    let result = [];<br>    if(root){<br>        finndPathCore(node,expectNum,[],0,result);<br>    }<br>    return result;<br>}</p>
<p>function findPathCore(node,expectNum,stack,num,result){<br>    stack.push(node.val);<br>    sum += node.val;<br>    if(!node.left &amp;&amp; !node.right &amp;&amp; sum===expctNum){<br>        result.push(stack.slice(0))<br>    }<br>    if(node.left){<br>        findPathCore(node.left,expectNum,stack,num,result);<br>    }<br>    if(node.right){<br>        findPathCore(node.right,expectNum,stack,num,result);<br>    }<br>    stack.pop()<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 中序遍历</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">给定一个二叉树，返回它的 中序 遍历。</span><br></pre></td></tr></table></figure>

<p>// 递归实现<br>var inorderTraverse =  function(root,arry=[]){<br>    if(root){<br>        inorderTraverse(node.left,arry);<br>        arry.push(node.val);<br>        inorderTravers(node.right,arry);</p>
<pre><code>}
return arry;</code></pre><p>}<br>// 非递归实现<br>//•取跟节点为目标节点，开始遍历<br>//•1.左孩子入栈 -&gt; 直至左孩子为空的节点<br>//•2.节点出栈 -&gt; 访问该节点<br>//•3.以右孩子为目标节点，再依次执行1、2、3</p>
<p>var  inorderTraverse = function(root){<br>    let result = [];<br>    let stack = [];<br>    let current = root ;<br>    while(current||stack.lenth&gt;0){<br>        while(current){<br>            stack.push(current);<br>            current = current.left;<br>        }<br>        current = stack.pop();<br>        result.push(current.val);<br>        current = current.right;<br>    }<br>    return reslut;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#### 求二叉树最大深度  递归，分治</span><br><span class="line">给定一个二叉树，找出其最大深度。</span><br><span class="line"></span><br><span class="line">二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br><span class="line">给定一个二叉树，找出其最大深度。</span><br><span class="line"></span><br><span class="line">二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure>

<p>function treeDepth(root){<br>    return !root? 0 “: Math.max(treeDept(root.left),treeDepth(root.right))+1;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">####  求二叉树最小深度  递归，分治</span><br><span class="line"></span><br><span class="line">思路</span><br><span class="line"></span><br><span class="line">深度优先 + 分治</span><br><span class="line">•左右子树都不为空：左子树深度和右子树最小深度的最小值 + 1</span><br><span class="line">•左树为空：右子树最小深度的最小值 + 1</span><br><span class="line">•右树为空：左子树最小深度 + 1</span><br></pre></td></tr></table></figure>

<p>var minDepth = function (root) {<br>      if (!root) {<br>        return 0;<br>      }<br>      if (!root.left) {<br>        return 1 + minDepth(root.right);<br>      }<br>      if (!root.right) {<br>        return 1 + minDepth(root.left);<br>      }<br>      return Math.min(minDepth(root.left), minDepth(root.right)) + 1<br>    };</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 深度优先遍历</span><br><span class="line"></span><br><span class="line">#### 广度优先遍历</span><br><span class="line"></span><br><span class="line">#### 快速排序</span><br></pre></td></tr></table></figure>

<p>function quick_sort(arr) {<br> if (arr.length &lt;= 1) {<br> return arr;<br> }<br> let pivot = arr[0]<br> let left = [];<br> let right = [];<br> for (let i = 1; i &lt; arr.length; i++) {<br> if (arr[i] &lt; pivot) {<br> left.push(arr[i]);<br> } else {<br> right.push(arr[i]);<br> }<br> }<br> return quick_sort(left).concat([pivot], quick_sort(right));<br>}<br>var arr = [5,4,6,7,1,2,8,9,3];<br>console.log(quick_sort(arr));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原地快排序</span><br><span class="line">不占⽤额外存储空间 原地交换位置</span><br></pre></td></tr></table></figure>

<p>function quick_sort1(arr) {<br> if (arr.length &lt;= 1) {<br> return arr;<br> }<br> let pivot = arr[0]<br> let i = 1<br> let j = arr.length-1<br> while(i&lt;j){<br> let pivot = arr[0]<br> while(arr[j]&gt;=pivot &amp;&amp; i&lt;j){<br> j –<br> }<br> while(arr[i]&lt;=pivot &amp;&amp; i&lt;j){<br> i ++<br> }<br> let temp = arr[i]<br> arr[i] = arr[j]<br> arr[j] = temp<br>  }<br> let left = arr.slice(1,i+1)<br> let right = arr.slice(j+1)<br> return […quick_sort1(left), pivot, …quick_sort1(right)]<br>}<br>console.log(quick_sort1(arr));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### flat多维数组降维</span><br><span class="line"></span><br><span class="line">&gt;原生Array.prototype.flat性能最好</span><br><span class="line">&gt; 语法：var newArray = arr.flat([depth]) depth默认为1</span><br></pre></td></tr></table></figure>

<p> var arr3 = [1, 2, [3, 4, [5, 6]]];<br>arr3.flat(2);<br>// [1, 2, 3, 4, 5, 6]</p>
<p>//使用 Infinity，可展开任意深度的嵌套数组<br>var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];<br>arr4.flat(Infinity);<br>// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;递归</span><br></pre></td></tr></table></figure>

<p>// forEach 遍历数组会自动跳过空元素<br>const eachFlat = (arr = [], depth = 1) =&gt; {<br>  const result = []; // 缓存递归结果<br>  // 开始递归<br>  (function flat(arr, depth) {<br>    // forEach 会自动去除数组空位，同样的还有filter, every some<br>    arr.forEach((item) =&gt; {<br>      // 控制递归深度<br>      if (Array.isArray(item) &amp;&amp; depth &gt; 0) {<br>        // 递归数组<br>        flat(item, depth - 1)<br>      } else {<br>        // 缓存元素<br>        result.push(item)<br>      }<br>    })<br>  })(arr, depth)<br>  // 返回递归结果<br>  return result;<br>} </p>
<p>// for of 循环不能去除数组空位，需要手动去除<br>const forFlat = (arr = [], depth = 1) =&gt; {<br>  const result = [];<br>  (function flat(arr, depth) {<br>    for (let item of arr) {<br>      if (Array.isArray(item) &amp;&amp; depth &gt; 0) {<br>        flat(item, depth - 1)<br>      } else {<br>        // 去除空元素，添加非undefined元素<br>        item !== void 0 &amp;&amp; result.push(item);<br>      }<br>    }<br>  })(arr, depth)<br>  return result;<br>}</p>
<p>// 递归版本的反嵌套<br>function flatten(array) {<br>  var flattend = [];<br>  (function flat(array) {<br>    array.forEach(function(el) {<br>      if (Array.isArray(el)) flat(el);<br>      else flattend.push(el);<br>    });<br>  })(array);<br>  return flattend;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;使用堆栈</span><br></pre></td></tr></table></figure>

<p>/ 无递归数组扁平化，使用堆栈<br>// 注意：深度的控制比较低效，因为需要检查每一个值的深度<br>// 也可能在 shift / unshift 上进行 w/o 反转，但是末端的数组 OPs 更快<br>var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];<br>function flatten(input) {<br>  const stack = […input];<br>  const res = [];<br>  while (stack.length) {<br>    // 使用 pop 从 stack 中取出并移除值<br>    const next = stack.pop();<br>    if (Array.isArray(next)) {<br>      // 使用 push 送回内层数组中的元素，不会改动原始输入<br>      stack.push(…next);<br>    } else {<br>      res.push(next);<br>    }<br>  }<br>  // 反转恢复原数组的顺序<br>  return res.reverse();<br>}<br>flatten(arr1);// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;generate</span><br></pre></td></tr></table></figure>

<p>function* flatten(array) {<br>    for (const item of array) {<br>        if (Array.isArray(item)) {<br>            yield* flatten(item);<br>        } else {<br>            yield item;<br>        }<br>    }<br>}</p>
<p>var arr = [1, 2, [3, 4, [5, 6]]];<br>const flattened = […flatten(arr)];<br>// [1, 2, 3, 4, 5, 6]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 求最长子字符串（或最长子字符串长度）</span><br></pre></td></tr></table></figure>

<p>// bad 暴力破解<br>/**</p>
<ul>
<li><p>@param {string} s</p>
</li>
<li><p>@return {number}</p>
</li>
<li><p>/<br>var lengthOfLongestSubstring = function(s) {<br>  const len = s.length<br>  let index = 0,i=0<br>  let temStr = ‘’<br>  let ss<br> let sChar = s.charAt(index)<br>  while(i&lt;len){</p>
<pre><code>if(sChar !== s.charAt(i)){
    if(i===len-1){
         temStr = s.slice(index,len)
    }
     i++
}else{
    ss = s.slice(index,i)
    if(ss.length&gt;=temStr.length){
        temStr = ss
    }
    i = index++
}</code></pre><p>  }<br>  return temStr.length</p>
</li>
</ul>
<p>};</p>
<p>// good 尺取法<br>// 思路：<br>//初始化两个指针（head,tail）指向字符串开头<br>//tail++,如果tail指针指向的字符不与head和tail-1之间的字符重复，tail继续向后移动，更新max；反之，head一直加到没有重复字符为止<br>//重复第二步骤，直到tail指针指向字符串结尾</p>
<p>/**</p>
<ul>
<li>@param {string} s</li>
<li>@return {number}</li>
<li>/<br>var lengthOfLongestSubstring = function(s) {<br>  const len = s.length<br> let left = 0<br> let max = 0<br> let temp = []<br> let maxStr = ‘’<br> let char<br> for(let i=0;i&lt;len;i++){<pre><code>char = s[i]
if(temp[char]&gt;=left){
    // 遇到重复的字符串
    left = temp[char]+1
}
temp[char] = i
if(max&lt;i-left+1){
    max = i-left+1
    maxStr = s.slice(left,i+1)
}</code></pre> }<br> return max</li>
</ul>
<p>};</p>
<p>/**</p>
<ul>
<li>@param {string} s</li>
<li>@return {number}</li>
<li>/<br>var lengthOfLongestSubstring = function(s) {<br>  const len = s.length<br> let left = 0<br> let map = {}<br>return s.split(“”).reduce((max,v,i)=&gt;{<pre><code>left = map[v]&gt;=left?map[v]+1:left
map[v] = i
return Math.max(max,i-left+1)</code></pre>},0)<br>};<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 两数之和</span><br><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>/**</p>
<ul>
<li>@param {number[]} nums</li>
<li>@param {number} target</li>
<li>@return {number[]}</li>
<li>/<br>var twoSum = function(nums, target) {<br> let tmp = []  // 使用数组比使用map节约内存<br> for(let i=0;i&lt;nums.length;i++){<pre><code>const diff = target-nums[i]
if(tmp[diff]!==undefined){
    return [tmp[diff],i]
}
tmp[nums[i]]=i</code></pre> }</li>
</ul>
<p>};<br>```</p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年06月17日 18:28</p>
        <p>原始链接： <a class="post-url" href="/2019/08/04/algorithms/" title="数据结构与算法">https://luhu9012.github.io/2019/08/04/algorithms/</a></p>
        <footer>
            <a href="https://luhu9012.github.io">
                <img src="/images/logo.png" alt="luhu9012">
                luhu9012
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://luhu9012.github.io/2019/08/04/algorithms/&title=《数据结构与算法》 — 前端笔记&pic=https://luhu9012.github.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://luhu9012.github.io/2019/08/04/algorithms/&title=《数据结构与算法》 — 前端笔记&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://luhu9012.github.io/2019/08/04/algorithms/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《数据结构与算法》 — 前端笔记&url=https://luhu9012.github.io/2019/08/04/algorithms/&via=https://luhu9012.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://luhu9012.github.io/2019/08/04/algorithms/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://luhu9012.github.io/2019/08/04/algorithms/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/树/" class="color2">树</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8种常用数据结构"><span class="post-toc-text">8种常用数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#数组"><span class="post-toc-text">数组</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#链表"><span class="post-toc-text">链表</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#常用的算法分类"><span class="post-toc-text">常用的算法分类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#复杂度分析：时间复杂度-、-空间复杂度"><span class="post-toc-text">复杂度分析：时间复杂度 、 空间复杂度</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2019/08/08/todo/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          todo
        
      </span>
    </a>
  
  
    <a href="/2019/08/03/crossDomain/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">跨域</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 luhu9012<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://luhu9012.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/bom/">bom</a><a class="category-link" href="/categories/css/">css</a><a class="category-link" href="/categories/js实践/">js实践</a><a class="category-link" href="/categories/js异步编程/">js异步编程</a><a class="category-link" href="/categories/动画/">动画</a><a class="category-link" href="/categories/框架/">框架</a><a class="category-link" href="/categories/设计模式/">设计模式</a><a class="category-link" href="/categories/项目/">项目</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/async-异步/" style="font-size: 10px;">async 异步</a> <a href="/tags/bfc/" style="font-size: 10px;">bfc</a> <a href="/tags/css-概念/" style="font-size: 10px;">css 概念</a> <a href="/tags/css动画-js动画/" style="font-size: 10px;">css动画 js动画</a> <a href="/tags/es6-语法/" style="font-size: 10px;">es6 语法</a> <a href="/tags/javaSciript/" style="font-size: 20px;">javaSciript</a> <a href="/tags/js-函数/" style="font-size: 10px;">js 函数</a> <a href="/tags/js-机制/" style="font-size: 10px;">js 机制</a> <a href="/tags/js基础-js运行机制/" style="font-size: 10px;">js基础 js运行机制</a> <a href="/tags/oop/" style="font-size: 10px;">oop</a> <a href="/tags/vue-js/" style="font-size: 10px;">vue.js</a> <a href="/tags/垂直居中/" style="font-size: 10px;">垂直居中</a> <a href="/tags/奇技淫巧/" style="font-size: 10px;">奇技淫巧</a> <a href="/tags/性能/" style="font-size: 16.67px;">性能</a> <a href="/tags/文件上传/" style="font-size: 13.33px;">文件上传</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/浏览器-V8/" style="font-size: 10px;">浏览器  V8</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/项目/" style="font-size: 13.33px;">项目</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/async-异步/" style="font-size: 10px;">async 异步</a> <a href="/tags/bfc/" style="font-size: 10px;">bfc</a> <a href="/tags/css-概念/" style="font-size: 10px;">css 概念</a> <a href="/tags/css动画-js动画/" style="font-size: 10px;">css动画 js动画</a> <a href="/tags/es6-语法/" style="font-size: 10px;">es6 语法</a> <a href="/tags/javaSciript/" style="font-size: 20px;">javaSciript</a> <a href="/tags/js-函数/" style="font-size: 10px;">js 函数</a> <a href="/tags/js-机制/" style="font-size: 10px;">js 机制</a> <a href="/tags/js基础-js运行机制/" style="font-size: 10px;">js基础 js运行机制</a> <a href="/tags/oop/" style="font-size: 10px;">oop</a> <a href="/tags/vue-js/" style="font-size: 10px;">vue.js</a> <a href="/tags/垂直居中/" style="font-size: 10px;">垂直居中</a> <a href="/tags/奇技淫巧/" style="font-size: 10px;">奇技淫巧</a> <a href="/tags/性能/" style="font-size: 16.67px;">性能</a> <a href="/tags/文件上传/" style="font-size: 13.33px;">文件上传</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/浏览器-V8/" style="font-size: 10px;">浏览器  V8</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/项目/" style="font-size: 13.33px;">项目</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>